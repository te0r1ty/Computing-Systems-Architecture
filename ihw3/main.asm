# Загрузка текста, превышающего буфер для его чтения
# с размещением в динамической памяти
.include "replacer.s"

.eqv    NAME_SIZE 256	# Размер буфера для имени файла
.eqv    TEXT_SIZE 512	# Размер буфера для текста

.data
	er_name_mes:    .asciz "Incorrect file name\n"
	er_read_mes:    .asciz "Incorrect read operation\n"
	
	test1:    .asciz "test1.txt"
	out1:    .asciz "out1.txt"
	
	test2:    .asciz "test2.txt"
	out2:    .asciz "out2.txt"
	
	test3:    .asciz "test3.txt"
	out3:    .asciz "out3.txt"
	
	file_name:      .space	NAME_SIZE		# Имячитаемого файла
	strbuf:		.space TEXT_SIZE		# Буфер для читаемого текста
.text
main:
###############################################################TEST1############################################################
    open(test1, READ_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    allocate(TEXT_SIZE)			# Результат хранится в a0
    mv 		s3, a0			# Сохранение адреса кучи в регистре
    mv 		s5, a0			# Сохранение изменяемого адреса кучи в регистре
    li		s4, TEXT_SIZE		# Сохранение константы для обработки
    mv		s6, zero		# Установка начальной длины прочитанного текста
    li		s7, 10240		# Максимальный размер читаемого файла
read_loop1:
    read_addr_reg(s0, s5, TEXT_SIZE)
    mv   	s2 a0       		# Сохранение длины текста
    add 	s6, s6, s2		# Размер текста увеличивается на прочитанную порцию
    bne		s2 s4 end_loop1
    beq		s6 s7 end_loop1
    allocate(TEXT_SIZE)			# Результат здесь не нужен, но если нужно то...
    add		s5 s5 s2		# Адрес для чтения смещается на размер порции
    b read_loop1				# Обработка следующей порции текста из файла
end_loop1:
    close(s0)
    replace_digits(s3, s5, s6)
    la	t0 strbuf			# Адрес начала буфера
    add t0 t0 s6			# Адрес последнего прочитанного символа
    addi t0 t0 1			# Место для нуля
    sb	zero (t0)			# Запись нуля в конец текста
    open(out1, WRITE_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    li   a7, 64       			# Системный вызов для записи в файл
    mv   a0, s0 			# Дескриптор файла
    mv   a1, s3  			# Адрес буфера записываемого текста
    mv   a2, s6    			# Размер записываемой порции из регистра
    ecall             			# Запись в файл
###############################################################TEST2###############################################################
    open(test2, READ_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    allocate(TEXT_SIZE)			# Результат хранится в a0
    mv 		s3, a0			# Сохранение адреса кучи в регистре
    mv 		s5, a0			# Сохранение изменяемого адреса кучи в регистре
    li		s4, TEXT_SIZE		# Сохранение константы для обработки
    mv		s6, zero		# Установка начальной длины прочитанного текста
    li		s7, 10240		# Максимальный размер читаемого файла
read_loop2:
    read_addr_reg(s0, s5, TEXT_SIZE)
    mv   	s2 a0       		# Сохранение длины текста
    add 	s6, s6, s2		# Размер текста увеличивается на прочитанную порцию
    bne		s2 s4 end_loop2
    beq		s6 s7 end_loop2
    allocate(TEXT_SIZE)			# Результат здесь не нужен, но если нужно то...
    add		s5 s5 s2		# Адрес для чтения смещается на размер порции
    b read_loop2				# Обработка следующей порции текста из файла
end_loop2:
    close(s0)
    replace_digits(s3, s5, s6)
    la	t0 strbuf			# Адрес начала буфера
    add t0 t0 s6			# Адрес последнего прочитанного символа
    addi t0 t0 1			# Место для нуля
    sb	zero (t0)			# Запись нуля в конец текста
    open(out2, WRITE_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    li   a7, 64       			# Системный вызов для записи в файл
    mv   a0, s0 			# Дескриптор файла
    mv   a1, s3  			# Адрес буфера записываемого текста
    mv   a2, s6    			# Размер записываемой порции из регистра
    ecall             			# Запись в файл
###############################################################TEST3###############################################################
    open(test3, READ_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    allocate(TEXT_SIZE)			# Результат хранится в a0
    mv 		s3, a0			# Сохранение адреса кучи в регистре
    mv 		s5, a0			# Сохранение изменяемого адреса кучи в регистре
    li		s4, TEXT_SIZE		# Сохранение константы для обработки
    mv		s6, zero		# Установка начальной длины прочитанного текста
    li		s7, 10240		# Максимальный размер читаемого файла
read_loop3:
    read_addr_reg(s0, s5, TEXT_SIZE)
    mv   	s2 a0       		# Сохранение длины текста
    add 	s6, s6, s2		# Размер текста увеличивается на прочитанную порцию
    bne		s2 s4 end_loop3
    beq		s6 s7 end_loop3
    allocate(TEXT_SIZE)			# Результат здесь не нужен, но если нужно то...
    add		s5 s5 s2		# Адрес для чтения смещается на размер порции
    b read_loop3			# Обработка следующей порции текста из файла
end_loop3:
    close(s0)
    replace_digits(s3, s5, s6)
    la	t0 strbuf			# Адрес начала буфера
    add t0 t0 s6			# Адрес последнего прочитанного символа
    addi t0 t0 1			# Место для нуля
    sb	zero (t0)			# Запись нуля в конец текста
    open(out3, WRITE_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    li   a7, 64       			# Системный вызов для записи в файл
    mv   a0, s0 			# Дескриптор файла
    mv   a1, s3  			# Адрес буфера записываемого текста
    mv   a2, s6    			# Размер записываемой порции из регистра
    ecall             			# Запись в файл
###############################################################MAIN!###############################################################
    print_str ("Input path to file for reading: ") # Вывод подсказки
    # Ввод имени файла с консоли эмулятора
    str_get(file_name, NAME_SIZE)
    open(file_name, READ_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    beq		a0 s1 er_name4		# Ошибка открытия файла
    mv   	s0 a0       		# Сохранение дескриптора файла
    ###############################################################
    # Выделение начального блока памяти для для буфера в куче
    allocate(TEXT_SIZE)			# Результат хранится в a0
    mv 		s3, a0			# Сохранение адреса кучи в регистре
    mv 		s5, a0			# Сохранение изменяемого адреса кучи в регистре
    li		s4, TEXT_SIZE		# Сохранение константы для обработки
    mv		s6, zero		# Установка начальной длины прочитанного текста
    ###############################################################
    li		s7, 10240		# Максимальный размер читаемого файла
read_loop4:
    # Чтение информации из открытого файла
    read_addr_reg(s0, s5, TEXT_SIZE) 	# чтение для адреса блока из регистра
    # Проверка на корректное чтение
    beq		a0 s1 er_read4		# Ошибка чтения
    mv   	s2 a0       		# Сохранение длины текста
    add 	s6, s6, s2		# Размер текста увеличивается на прочитанную порцию
    # При длине прочитанного текста меньшей, чем размер буфера, либо когда прочитанный материал
    # превышает превышает лимит, необходимо завершить процесс.
    bne		s2 s4 end_loop4
    beq		s6 s7 end_loop4
    # Иначе расширить буфер и повторить
    allocate(TEXT_SIZE)			# Результат здесь не нужен, но если нужно то...
    add		s5 s5 s2		# Адрес для чтения смещается на размер порции
    b read_loop4				# Обработка следующей порции текста из файла
end_loop4:
    ###############################################################
    # Закрытие файла
    close(s0)
    
    replace_digits(s3, s5, s6)
    
    ###############################################################
    # Установка нуля в конце прочитанной строки
    la	t0 strbuf			# Адрес начала буфера
    add t0 t0 s6			# Адрес последнего прочитанного символа
    addi t0 t0 1			# Место для нуля
    sb	zero (t0)			# Запись нуля в конец текста
    
    ###############################################################
    # Сохранение прочитанного файла в другом файле
    print_str ("\n\n")
    print_str ("\n")
    print_str ("Input path to file for writing: ")
    str_get(file_name, NAME_SIZE)	# Ввод имени файла с консоли эмулятора
    open(file_name, WRITE_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    mv   	s0 a0       		# Сохранение дескриптора файла
    
    ###############################################################
    # Запись информации в открытый файл
    li   a7, 64       			# Системный вызов для записи в файл
    mv   a0, s0 			# Дескриптор файла
    mv   a1, s3  			# Адрес буфера записываемого текста
    mv   a2, s6    			# Размер записываемой порции из регистра
    ecall             			# Запись в файл


    yorn
    li t6 78
    beq a0 t6 gg
    
    # Вывод текста на консоль
    mv		a0, s3			# Адрес начала буфера из кучи
    li 	a7 4
    ecall
    # Вывод числа байт, в прочитанном файле
    print_str ("\nThere is bytes in the source file: ")
    print_int(s6)
    newline
    # Использование strlen для подсчета числа байт
    print_str ("strlrn for the source file: ")
    mv 	a0, s3
    jal strlen
    print_int(a0)
    newline
    
    
gg:           
    # Завершение  программы
    exit
er_name4:
    # Сообщение об ошибочном имени файла
    la		a0 er_name_mes
    li		a7 4
    ecall
    # И завершение программы
    exit
er_read4:
    # Сообщение об ошибочном чтении
    la		a0 er_read_mes
    li		a7 4
    ecall
    # И завершение программы
    exit
